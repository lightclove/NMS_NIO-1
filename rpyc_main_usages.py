"""
    RPyC (произносится как «а-пай-си») или «Удаленный вызов Python» — 
    это библиотека Python для удаленных вызовов процедур (RPC), 
    а также для распределенных вычислений. 
    В отличие от обычных механизмов RPC, таких как ONC RPC, CORBA или Java RMI, 
    RPyC прозрачен, симметричен и не требует специального оформления или языков определения. 
    Более того, он оБЕСПЕЧИВАЕТ ПРОГРАММНЫЙ ДОСТУП К ЛЮБОМУ ПИТОНИЧЕСКОМУ ЭЛЕМЕНТУ, 
    будь то функции, классы, экземпляры или модули.
    RPyC использует проксирование объектов, метод, 
    использующий динамическую природу Python, 
    для преодоления физических границ между процессами и компьютерами, 
    чтобы можно было манипулировать удаленными объектами, 
    как если бы они были локальными.
    RPyC:
    ❗Симметричный — нет никакой разницы между клиентом и сервером — оба могут обслуживать. 
    ❗Единственным отличием является то, что клиент обычно является стороной, которая инициирует действие. 
    ❗Например, симметричность позволяет клиенту передавать функции обратного вызова на сервер.
    ❗Прозрачный — удаленные объекты выглядят и ведут себя так же, как локальные объекты.
    ❗Исключения распространяются как локальные
    ❗Позволяет синхронную и асинхронную работу:
        Синхронные операции возвращают NetProxy
        Асинхронные операции возвращают AsyncResult, который подобен объектам-обещаниям.
        AsyncResults можно использовать как события

    Потоки поддерживаются (хотя и не рекомендуются)
    Специально для UNIX: интеграция сервера с inetd
    Система удаленного вызова процедур (RPC) позволяет вам вызывать функцию, 
    доступную на удаленном сервере, используя тот же синтаксис, 
    который используется при вызове функции в локальной библиотеке. 
    Это полезно в двух ситуациях.
    ❗Вы можете использовать вычислительную мощность нескольких машин, используя rpc, 
    не изменяя код для вызова программ, расположенных в удаленных системах.
    ❗Данные, необходимые для обработки, доступны только в удаленной системе.
    Таким образом, в python мы можем рассматривать одну машину как сервер, 
    а другую машину как клиент, который будет вызывать сервер для запуска удаленной процедуры. 

    В нашем примере мы возьмем локальный хост и будем использовать его и как сервер, и как клиент.
    Как только клиент подключается к серверу, он может выполнять удаленные операции одним из двух способов:

    Свойство модулей, раскрывающее пространство имен модулей сервера: 
    doc = conn.modules.sys.path или conn.modules['xml.dom.minidom'].parseString('somexml/some').
    Функция выполнения, которая выполняет данный код на сервере: conn.execute('print 'hello world'')
    
    Удаленные операции возвращают нечто, называемое NetProxy, который является промежуточным объектом, 
    отражающим любую операцию, выполненную на нем локально, удаленному объекту. 
    Например, conn.modules.sys.path — это NetProxy для объекта sys.path сервера. 
    Любые локальные изменения, внесенные в conn.modules.sys.path, немедленно отражаются на удаленном объекте. 
    Примечание. NetProxy не используются для простых объектов, таких как числа и строки, которые являются неизменяемыми.
    Async — это прокси-оболочка, то есть он принимает NetProxy и возвращает другой, 
    который обертывает его асинхронной функциональностью. 
    Операции, выполненные с AsyncNetProxy, возвращают нечто, называемое AsyncResult. 
    Эти объекты имеют предикат '.is_ready', свойство '.result', которое хранит результат 
    (или блокирует его до тех пор, пока он не будет получен), и обратный вызов '.on_ready', 
    который будет вызываться при поступлении результата.
    
    Случаи использования RPyC. 
    Первоначально RPyC был разработан для управления распределенным тестированием продуктов на различных платформах 
    (все они могут работать с Python). 
    Однако с тех пор RPyC развился, и теперь варианты его использования включают:
    ❗Распределенные вычисления (распределение рабочей нагрузки между машинами)
    ❗Распределенное тестирование (запуск тестов, соединяющих несколько платформ и абстрагирующих аппаратные ресурсы)
    ❗Удаленное администрирование (настройка файлов конфигурации из одного центрального места и т. д.)
    ❗Туннелирование или цепочка (пересечение границ маршрутизируемой сети)
    ---------------------------------------------------------------------------------------------------------------------
    
    Запуск сервера.

    Язык Python поставляется со встроенным сервером, который мы можем запустить как локальный сервер. 
    Сценарий для запуска этого сервера находится в папке bin установки Python и называется classic.py. 
    Мы можем запустить его в командной строке python и проверить, работает ли он как локальный сервер.

    Компьютерный кластер , метод соединения множества компьютеров вместе, чтобы они работали как один компьютер.
    Кластер данных, выделение непрерывного хранилища в базах данных и файловых системах.
    Кластерный анализ , статистическая задача группировки набора объектов таким образом, 
    чтобы объекты в одной группе располагались ближе друг к другу (например, кластеризация k-средних)
    В хеш-таблицах сопоставление ключей с соседними слотами
    RPC - это форма межпроцессного взаимодействия (IPC), в которой разные процессы имеют разные адресные пространства: 
    если они находятся на одном хост-компьютере, у них есть разные виртуальные адресные пространства, 
    даже если физическое адресное пространство одно и то же; в то время как если они находятся на разных хостах, 
    физическое адресное пространство отличается. 
    Для реализации этой концепции использовалось множество различных (часто несовместимых) технологий.
"""
# Для установки RPyC:
# pip install rpyc
# Запуск сервера в отдельном "терминале": 
# python3 /home/user/.local/bin/rpyc_classic.py # В документации указано просто bin/rpyc_classic.py
# INFO:SLAVE/18812:server started on [127.0.0.1]:18812
# SLAVE указывает на SlaveService, а
# [127.0.0.1]:18812 — это адрес, по которому привязывается сервер, 
# в этом случае сервер будет принимать соединения только с локального хоста. 
# Если вы запускаете сервер с параметром --host 0.0.0.0, вы можете выполнять произвольный код из любого места.

#  Следующим шагом является запуск клиента, который подключается к серверу:
import rpyc
conn = rpyc.classic.connect("localhost")
# Если ваш сервер не использует порт по умолчанию (TCP 18812), 
# вам нужно будет передать параметр port= в classic.connect().

# Свойство modules объектов соединения раскрывает пространство модулей сервера, 
# т. е. позволяет получить доступ к удаленным модулям. Вот как:
rsys=conn.modules.sys

# Эта запись через точку работает только для модулей верхнего уровня. 
# Всякий раз, когда вам потребуется вложенный импорт для модулей, 
# содержащихся в пакете, вы должны использовать скобки для импорта удаленного модуля, например:
minidom = conn.modules["xml.dom.minidom"]

# Например, вот как вы видите командную строку сервера:
rsys.argv # ['bin/rpyc_classic.py']

#…добавьте пути поиска модулей для механизма импорта сервера:
rsys.path.append('/tmp/totally-secure-package-location')

#…изменить текущий рабочий каталог серверного процесса:
conn.modules.os.chdir('..')

#… или даже вывести что-нибудь на стандартный вывод сервера:
print("Hello World!", file=conn.modules.sys.stdout)

# Свойство встроенных функций классического подключения предоставляет все встроенные функции, 
# доступные в среде python сервера. Вы можете использовать его, например, для доступа к файлу на сервере:
# f = conn.builtins.open('/home/oblivious/.ssh/id_rsa')
# f.read() # '-----BEGIN RSA PRIVATE KEY-----\nMIIJKQIBAAKCAgEA0...XuVmz/ywq+5m\n-----END RSA PRIVATE KEY-----\n' 

# классические соединения также имеют свойства eval и execute, 
# которые позволяют вам напрямую оценивать произвольные выражения или даже выполнять произвольные операторы на сервере. Например:
#>>> conn.execute('import math') # No output
#>>> conn.eval('2*math.pi') # 6.283185307179586

# классические соединения rpyc имели какое-то представление о глобальных переменных, 
# как вы можете их увидеть? 
# Они доступны через свойство пространства имен, которое будет инициализировано как пустой словарь для каждого нового соединения. 
# Итак, после нашего импорта у нас теперь есть:
# та же функциональность может быть достигнута с помощью функции conn.builtins.compile(), 
# которая также доступна через conn.modules.builtins.compile(), и вручную загрузив его удаленно созданным словарем

# Есть еще один интересный метод, который позволяет передавать функции на другие стороны и выполнять их там:
# Это вычисляет квадрат двух, как и ожидалось, но вычисление происходит на удаленном компьютере!
#>>> def square(x):
#...    return x**2
#>>> fn = conn.teleport(square)
#>>> fn(2)
# Кроме того, телепортируемые функции автоматически определяются в удаленном пространстве имен:

# Когда клиент делает запрос, который завершается ошибкой (исключение возникает на стороне сервера), 
# исключение прозрачно распространяется на клиента. 
# Взгляните на этот фрагмент:
#>>> conn.modules.sys.path[300]         # there are only 12 elements in the list...
# IndexError: list index out of range
# Как видите, мы получаем две трассировки: удаленную, показывающую, что пошло не так на сервере, 
# и локальную, показывающую, что мы сделали, чтобы это вызвать

# Кастомная обработка исключений сервером *
# The server example:
import rpyc
import urllib.error
from rpyc.utils.server import OneShotServer


class HelloService(rpyc.Service):
    def exposed_foobar(self, remote_str):
        raise urllib.error.URLError("test")


if __name__ == "__main__":
    rpyc.lib.setup_logger()
    server = OneShotServer(
        HelloService,
        port=12345,
        protocol_config={'import_custom_exceptions': True}
    )
    server.start()

# The client example:
import rpyc
import urllib.error
rpyc.core.vinegar._generic_exceptions_cache["urllib.error.URLError"] = urllib.error.URLError

if __name__ == "__main__":
    conn = rpyc.connect("localhost", 12345)
    try:
        print(conn.root.foobar('hello'))
    except urllib.error.URLError:
        print('caught a URLError')
#############################################################################################################
# Передача «функции обратного вызова(Callbacks)» означает обращение с функциями 
# (или любыми вызываемыми объектами в нашем случае) 
# как с объектами первого класса, то есть как с любым другим значением в языке. 
# В C и C++ это делается с помощью указателей на функции, 
# но в python для этого нет специального механизма. 
# Наверняка вы уже видели обратные вызовы:
"""
>>> def f(x):
...     return x**2
...
>>> map(f, range(10))   # f is passed as an argument to map
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

"""
# Так как в питоне функции (как и любые другие значения) являются объектами, 
# а так как RPyC симметричен, 
# локальные функции можно передавать в качестве аргументов удаленным объектам, и наоборот. 
# Вот пример:
"""
>>> import rpyc
>>> c = rpyc.classic.connect("localhost")
>>> rlist = c.modules.builtins.list((0,1,2,3,4,5,6,7,8,9))  # this is a remote list
>>> rlist
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
>>> def f(x):
...     return x**3
...
>>> list(c.modules.builtins.map(f, rlist))  # calling the remote map with the local function f as an argument
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]

# и чтобы лучше понять предыдущий пример:

>>> def g(x):
...     print("hi, this is g, executing locally", x)
...     return x**3
...
>>> list(c.modules.builtins.map(g, rlist))

Как видите, пока клиент ожидает результата (синхронный запрос), 
он будет обслуживать все входящие запросы, 
то есть сервер может вызывать обратный вызов, 
который он получил на клиенте. 
Другими словами, симметрия RPyC означает, 
что и клиент, и сервер в конечном счете являются «серверами», 
а «роль» является скорее семантической, чем программной.

"""
